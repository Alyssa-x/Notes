# 网络

http1.0 1.1 2 3区别

http请求行有哪些字段^

http状态码^

tcp三次握手^

http与s区别

# 应用层

## 1.HTTP 协议

 超文本传输协议，定义了客户端与服务器之间交换报文的格式和方式，默认80端口。使用TCP作为传输层协议，保证了可靠性。

无状态的协议，HTTP服务器不会保存关于客户的任何信息。

### HTTP 两种连接方式

- 非持续连接  服务器必须为每个请求的对象建立和维护一个全新的链接
- 持续连接  TCP连接默认不关闭，可以被多个请求复用。避免每次建立TCP**三次握手**

### HTTP 请求报文

- 请求报文

  **请求行**（方法，URL字段，HTTP协议版本）

  ```js
  GET  / HTTP/1.1  
  ```
  首部行（报文头）包括若干属性，属性名：属性值格式。Accept，Referer，User-Agent，Content-Type，Cookie，Cache-control

  Accept：告诉服务端客户端接收什么类型的响应text/plain

  Cookie：传给服务端客户端的cookie

  Referer：请求从哪个URL过来的

  Cache-control：对缓存的控制。no-cache就是不要在客户端缓存

  ```js
  // 报文头（首部行？）
  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
  Accept: */*
  ```

### HTTP响应报文

```js
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```

状态行 ：协议版本，状态码，状态信息

首部行：分为请求首部、响应首部、通用首部和实体首部

请求首部： Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。

响应首部： ETag 资源的匹配信息，Location 客户端重定向的 URI。

通用首部： Cache-Control 控制缓存策略、Connection 管理持久连接。

实体首部： Content-Type实体主体的媒体类型，Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修 改时间。

## HTTP状态码

1xx 请求正在被处理

2xx 请求成功处理

3xx 请求需要附加操作，如重定向

4xx 客户端出错导致请求无法处理

5xx 服务端出错

```js
200：OK请求正常处理
204：请求处理成功，但是没有资源可返回
206：对资源的某一部分的请求
```

```js
301 moved permanently 永久性重定向，响应的头部字段`location`会返回一个新地址
302 Found 资源临时重定向， 同样有location
303 See other 还会告诉客户端要用get方法使用location
304 Not modified 资源未改变，可直接使用缓存。即协商缓存
305 使用代理 请求者只能用代理访问请求的网页
307 Temporary Redict 302时浏览器会转用GET方法请求location；如果是307，则不允许从post转为get，按照原来方法请求
```

```js
400 bad request 语法错误
401 Unauthorized 未经过认证，身份认证
403 Forbidden 无权访问
404 Not found
405 方法禁用 禁用请求中指定的方法
407 需要代理授权 
408 请求超时
410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应
415   （不支持的媒体类型） 请求的格式不受请求页面的支持
```

```js
500 Internal Server error 服务器故障
502 Bad gateway 服务器作为网关或代理，从上有服务器收到无效响应
503 Service unavailable 服务器暂时无法用，维护或超载
504 Gateway timeout 作为网关或代理的服务器访问超时
505 HTTP 版本不受支持 服务器不支持请求中所用的 HTTP 协议版本。
```

https://www.jianshu.com/p/283dd79775bb

## 2. HTTP vs HTTPS

传输信息安全性不同、连接方式不同、端口不同、证书申请方式不同

- 传输信息安全性不同

1、http协议：是超文本传输协议，信息是明文传输。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。

2、https协议：是具有安全性的 ssL/TLS(secure sockets layer安全套接层协议/ transport layer secure传输层安全协  加密算法不同的安全协议) 加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全。

- 连接方式不同

1、http协议：http的连接很简单，是无状态的。

2、https协议：是由SSL/TLS ＋HTTP协议构建的可进行加密传输（对称+非对称）、身份认证的网络协议。

- 端口不同

1、http协议：使用的端口是80。

2、https协议：使用的端口是443．

- 证书申请方式不同

1、http协议：免费申请。

2、https协议：需要到ca申请证书，一般免费证书很少，需要交费。

## 为什么加密

防止中间人攻击，劫持了数据

## 为什么非对称加密？

密钥传输时被人劫持了怎么办

## 对称 + 非对称

1. 某网站拥有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
4. 服务器拿到后用私钥A’解密得到密钥X。
5. 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。

### 数字证书

向ca机构申领一份数字证书，数字证书里含有证书持有者信息，公钥信息。服务器把证书传输给浏览器。**证明浏览器收到的公钥一定是该网站的公钥。**

明文 + 数字签名 => 数字证书

1. CA机构拥有非对称加密的私钥和公钥。

2. CA机构对证书明文数据T进行hash。

3. 对hash后的值用私钥加密，得到数字签名S

   https://zhuanlan.zhihu.com/p/43789231

# 传输层

## 2. TCP vs UDP

### TCP三次握手

1. 客户端向服务端发送一个连接请求的报文段，SYN标志位置为1，seq序列号为随机数x，表示客户端数据的初始序号。SYN-SENT
2. 服务端发送报文段，标志位SYN，ACK置为1，确认号字段为客户端发送的序号加一ack=x+1, seq序列号字段为随机数y。SYN-RCVD
3. 客户端发送报文段确认，ACK标志位置1，ack确认号字段为y+1，开始传输数据，序列号字段seq为x+1。ESTABLISHED

### TCP 四次挥手

因为 TCP 连接是全双工的，也就是说通信的双方都可以向对方发送和接收消息，所以断开连接需要双方的确认。

第一次挥手，客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，**申请断开客户端到服务器端的连接**。发送后客户端进入 FIN_WAIT_1 状态。

第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，**表示已经接收到了客户端释放连接的请求**，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，**服务器端还可以向客户端发送数据**。服务 器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。

第三次挥手，服务器端发送完所有数据后，向客户端发送 FIN 报文段，**申请断开服务器端到客户端的连接**。发送后进入 LAST_ACK 状态。

第四次挥手，客户端接收到 FIN 请求后，**向服务器端发送一个确认应答**，并进入 TIME_WAIT 阶段。该阶段会持续一段时间， 这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到 服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被 释放了。

TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。

最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭。

### 不同：

1. TCP面向连接，UDP无连接
2. tcp可靠传输（确认号，序号，定时重传，连续ARQ协议，滑动窗口），UDP最大努力交付，尽力而为，不保证数据可靠传输
3. tcp一对一，udp可以一对多
4. tcp有拥塞控制（慢开始，拥塞避免，快重传，快恢复），流量控制(tell server buffer)，UDP无，所以发送速率无限制
5. tcp全双工

连续ARQ：不用等收到一个ACK再发下一个；收到一个分组的确认，滑动窗口向前滑动一个分组的位置

滑动窗口：窗口中已经发送但未确认的报文段和允许发送但还未发送的报文段；在定时器的时间内收到某一个报文段的确认回答，则滑动窗口

拥塞控制：慢开始:一个ack，拥塞窗口加一；一个RTT(Round-Trip Time)往返时间后加倍

​					拥塞避免：窗口大小到达阈值之后，进入该状态。每过一个RTT，size+1，not 成倍

​					快重传：收到一个失序的报文段就立即发出重复确认，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待为其设置的重传计时器到期

​					快恢复：已经出现拥塞之后慢启动的阈值减小为一半，窗口size为该阈值，开始拥塞避免

# 4. cookie 和session 的区别

1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、所以个人建议：
  将登陆信息等重要信息存放为SESSION
  其他信息如果需要保留，可以放在COOKIE中					

# 5. HTTP1.0 1.1 2.0 3.0

## 1.0 vs 1.1

- 1.0 非持续连接，1.1 持续连接，多个http请求复用同一个tcp连接

- http1.1在请求头中加入了range，允许只请求资源的某个部分，返回206（partial content），减少浪费带宽

- 新增host字段，用于指定服务器的域名。1.0认为每台服务器只有一个唯一ip地址，但后来在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址

- 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略

- 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

- 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法

  （HTTP1.0 ： GET, POST 和HEAD方法。 HTTP1.1 ：OPTIONS、PUT、PATCH、DELETE、TRACE 和CONNECT 方法）

1.1 缺点：巨大的http头部，传输成本高；高延迟（因队头阻塞，按顺序的请求，前面的阻塞）

## 2.0

- 二进制协议

  在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是 二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。

- 多路复用

  HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，**客户端和服务器都可以同时发送多个请求或回应**，而且不用按照顺序一一发送，这样就避免了"队头堵塞"的问题。

- 头信息压缩

  头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面， 客户端和服务器同时维护一张头**信息表**，所有字段都存入这个表，生成一个索引号，以后就不发送同样字段了，**只发送索引号**，这样就能提高速度了

- 服务器推送

  HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源 ，这样就可以相对减少一些延迟时间

缺点：多路复用，一个数据流拥塞之后，使用一个TCP连接剩下的数据流就没法发出去。tcp协议的问题

## 3.0

由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC （quick udp Internet connection）协议，并且使用在了 HTTP/3 上。 QUIC 协议在 UDP 协议上实现了多路复用、TCP可靠传输机制、TLS安全加密，有序交付、重传等等功能

# 6. 对称 非对称加密

对称加密：私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快

非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。用公钥或私钥中的任何一个进行加密，用另一个进行解密。

# 7. 跨域

同源：协议，域名，端口号相同

同源政策：一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。

1. 当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。
2. 不能够操作访问操作其他域下的 DOM。
3.  ajax 无法发送跨域请求。

首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。

（1）**将 document.domain 设置为主域名，来实现相同子域名的跨域操作**，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。

如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。

（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。
**在 A 页面中改变 B 的 url 中的 hash 值，B 不会刷新，但是 B 可以用过`window.onhashchange`事件监听到 hash 变化**

（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以**不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面**。这个时候父级页面就可以访问不同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。

（4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过**获取到指定窗口的引用，然后调用 postMessage 来发送信息**，在窗口中我们通过**对 window的message 事件的监听来接收信息**，以此来实现不同源间的信息交换。

```js
postMessage(data,origin)

window.addEventListener('message',function(e){  if(e.source!=window.parent) return;window.parent.postMessage(color,'*');},false);
```



如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。

（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。

**jsonp来实现跨域请求，动态构建一个script标签，src中请求的url后制定一个回调函数，服务器收到请求后，会把数据放在回调函数的参数位置返回。前端会直接执行这个脚本文件，就调用了这个回调函数**

**缺点**：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。

（6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是"跨域资源共享"。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。非简单请求，浏览器会先发出一次预检请求，来判断**该域名是否在服务器的白名单中**，如果收到肯定回复后才会发起请求。

（7）使用 websocket 协议，这个协议没有同源限制。
var ws = new WebSocket("wss://echo.websoket.org"); //这个是后端端口
ws.onopen = function (evt) {
  ws.send("some message");
};
ws.onmessage = function (evt) {
  console.log(evt.data);
};
ws.onclose = function (evt) {
  console.log("连接关闭");
};

（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。

# 8. 强缓存 vs 协商缓存

1）浏览器在加载资源时，根据请求头的`expires`和`cache-control`判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。

2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过`last-modified`和`etag`验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源

3）如果前面两者都没有命中，直接从服务器加载资源

### Last-Modified，If-Modified-Since

`Last-Modified` 表示本地文件最后修改日期，浏览器会在request header加上`If-Modified-Since`（上次返回的`Last-Modified`的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来

但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag

### ETag、If-None-Match

`Etag`就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的

`If-None-Match`的header会将上次返回的`Etag`发送给服务器，询问该资源的`Etag`是否有更新，有变动就会发送新的资源回来

https://github.com/amandakelake/blog/issues/41

# 9. 缓存存储

1、cookie：4K，可以手动设置失效期
2、localStorage：5M，除非手动清除，否则一直存在
3、sessionStorage：5M，不可以跨标签访问，页面关闭就清理.sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的.不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息

4、indexedDB：浏览器端数据库，无限容量，除非手动清除，否则一直存在
5、Web SQL：关系数据库，通过SQL语句访问（已经被抛弃）

`localStorage`可以用于存储**该浏览器对该页面的访问次数**，当然，如果换个浏览器，这个次数就重新开始计数了。还可以用来**存储一些固定不变的页面信息**，这样就不需要每次都重新加载了，这个值也可以进行覆盖。

- 简单来说，`Cookie`就是服务器暂存放在你的电脑里的资料（`.txt`格式的文本文件），好让服务器用来辨认你的计算机。当你在浏览网站的时候，`Web`服务器会先送一小小资料放在你的计算机上，`Cookie` 会把你在网站上所打的文字或是一些选择都记录下来。当下次你再访问同一个网站，Web服务器会先看看有没有它上次留下的`Cookie`资料，有的话，就会依据`Cookie`里的内容来判断使用者，送出特定的网页内容给你。
- 网站可以利用`cookie`跟踪统计用户访问该网站的习惯，比如什么时间访问，访问了哪些页面，在每个网页的停留时间等。利用这些信息，一方面是可以为用户提供个性化的服务，另一方面，也可以作为了解所有用户行为的工具，对于网站经营策略的改进有一定参考价值。
- 目前`Cookie`最广泛的是记录用户登录信息，这样下次访问时可以不需要输入自己的用户名、密码了——当然这种方便也存在用户信息泄密的问题，尤其在多个用户共用一台电脑时很容易出现这样的问题。

`sessionStorage` 敏感账号一次性登录

# 10. 浏览器从输入URL之后的过程

1. 在浏览器地址栏输入 URL

2. 判断是否有永久重定向(301)

   1. 如果有，直接跳转到对应 URL

3. 浏览器查看资源是否有**强缓存**，有则直接使用，如果是**协商缓存**则需要到服务器进行校验资源是否可用

   1. 检验新鲜通常有两个 HTTP 头进行控制`Expires`和`Cache-Control`：
      - HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期
      - HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间

4. 浏览器**解析 URL**获取协议，主机，端口，path

5. 浏览器**组装一个 HTTP（GET）请求报文**

6. **DNS 解析**，查找过程如下：

   1. 浏览器缓存
   2. 本机缓存
   3. hosts 文件
   4. 路由器缓存
   5. ISP DNS 缓存
   6. DNS 查询（向本地DNS服务器递归查询 / 向各级域名服务器迭代查询）

   （DNS 协议提供的是一种**主机名到 IP 地址**的转换服务，就是我们常说的域名系统）

7. **端口建立 TCP 链接**，三次握手如下：

   1. 客户端向服务端发送一个连接请求的报文段，SYN标志位置为1，seq序列号为随机数x，表示客户端数据的初始序号。SYN-SENT
   2. 服务端发送报文段，标志位SYN，ACK置为1，确认号字段为客户端发送的序号加一ack=x+1, seq序列号字段为随机数y。SYN-RCVD
   3. 客户端发送报文段确认，ACK标志位置1，ack确认号字段为y+1，开始传输数据，序列号字段seq为x+1。ESTABLISHED

8. TCP 链接建立后**发送 HTTP 请求**

9. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序

10. 服务器检查**HTTP 请求头是否包含缓存验证信息**如果验证缓存新鲜，返回**304**等对应状态码

11. 处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作

12. 服务器将**响应报文通过 TCP 连接发送回浏览器**

13. 浏览器接收 HTTP 响应，然后根据情况选择**关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次挥手如下**：

    1. 主动方发送**Fin=1， Ack=Z， Seq= X**报文
    2. 被动方发送**ACK=X+1， Seq=Z**报文
    3. 被动方发送**Fin=1， ACK=X， Seq=Y**报文
    4. 主动方发送**ACK=Y， Seq=X**报文

14. 浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同

15. 如果资源可缓存，**进行缓存**

16. 对响应进行**解码**（例如 gzip 压缩）

17. 根据资源类型决定如何处理（假设资源为 HTML 文档）

18. **解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本**，这些操作没有严格的先后顺序，以下分别解释

19. **构建 DOM 树**：

    1. **Tokenizing**：根据 HTML 规范将字符流解析为标记
    2. **Lexing**：词法分析将标记转换为对象并定义属性和规则
    3. **DOM construction**：根据 HTML 标记关系将对象组成 DOM 树

20. 解析过程中遇到图片、样式表、js 文件，**启动下载**

21. 构建**CSSOM 树**：

    1. **Tokenizing**：字符流转换为标记流
    2. **Node**：根据标记创建节点
    3. **CSSOM**：节点创建 CSSOM 树

22. **[根据 DOM 树和 CSSOM 树构建渲染树](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction)**:

    1. 从 DOM 树的根节点遍历所有**可见节点**，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被 css 隐藏的节点，如`display: none`
    2. 对每一个可见节点，找到恰当的 CSSOM 规则并应用
    3. 发布可视节点的内容和计算样式

23. **js 解析如下**：

    1. 浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate 为 loading**
    2. HTML 解析器遇到**没有 async 和 defer 的 script 时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容**
    3. 当解析器遇到设置了**async**属性的 script 时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用 document.write()**，它们可以访问自己 script 和之前的文档元素
    4. 当文档完成解析，document.readState 变成 interactive
    5. 所有**defer**脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用 document.write()
    6. 浏览器**在 Document 对象上触发 DOMContentLoaded 事件**
    7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，document.readState 变为 complete,window 触发 load 事件

24. **显示页面**（HTML 解析过程中会逐步显示页面）

# 11.xss攻击

XSS 攻击指的是**跨站脚本攻击**，是一种**代码注入攻击**。攻击者通过在网站**注入恶意脚本**，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

XSS 一般分为存储型、反射型和 DOM 型。

存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。

反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。

DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。

XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。

对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。

因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。

还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。

还可以对一些敏感信息进行保护，比如 **cookie 使用 http-only **，使得脚本无法获取。如果设置了该值，表示该cookie仅能用于传输，而不允许在客户端通过`JS`获取也可以使用验证码，避免脚本伪装成用户执行一些操作。

`CSP `指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。

# 11.SQL注入攻击

SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。

# 12. CSRF 攻击

CSRF 攻击指的是**跨站请求伪造攻击**，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。

一般的 CSRF 攻击类型有三种：

第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提
交。

第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。

第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。

CSRF 可以用下面几种方法来防护：

第一种是**同源检测**的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时**把搜索引擎的链接也给屏蔽**了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。

第二种方法是使用 CSRF Token 来进行验证，**服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证**。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。

第三种方式使用**双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证**。使用这种方式是利用了**攻击者只能利用 cookie，但是不能访问获取 cookie **的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。

第四种方式是使用在设置 cookie 属性的时候设置 **Samesite **，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。

# 13. 端口

数据通过端口号把数据发送到指定的服务或程序上。

可以通过端口来建防火墙。有些公认端口分配给http服务，ftp服务。有一部分端口可以自己注册定义。

IP头有一个名为`Protocol`的字段，用于区分TCP和UDP端点。这样，只要通信协议不同，两个进程就可以绑定到同一个IP：端口。                                                                                      

# 14. SSR

服务端渲染就是在浏览器请求页面URL的时候，服务端将我们需要的HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中。

`客户端渲染：`
 又称为前端渲染，起源于js的兴起，ajax让前端渲染更加成熟，前端专注于ui，后端专注于逻辑，真正意义上实现了前后端的分离，通过约定好的API来交互，**后端提供数据，前端根据数据生成DOM插入HTML页面**。初次渲染大都是将原html中的数据标记{{}}替换，鼠标右击查看源码，页面代码不可以在源代码中看到，性能消耗在客户端

# 16. get vs post

1. **请求参数**： get是通过url传递的，多个参数以&连接，post请求放在request body里
2. **请求缓存**：get请求会被缓存，post请求不会，除非手动设置
3. **安全性**：OST比GET安全，GET请求在浏览器回退时是无害的，而POST会再次请求
4. **历史记录**：GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留。
5. **编码方式**：GET请求只能进行url编码，而POST支持多种编码方式。
6. **对参数的数据类型**：GET只接受ASCII字符，而POST没有限制
7. **收藏为书签**：GET请求支持，POST请求不支持

# 17.数组和链表的区别

1. 物理地址存储的连续性。数组在内存中是连续存放的，需预留空间；链表元素在内存中不一定是连续存放
2. 访问速度不同。数组可以直接通过下标定位，从首地址向后偏移；链表空间分散，无随机访问性，需要移动指针遍历
3. 增删元素速度不同。数组效率低，因为需要移动大量元素。链表只需修改指针
4. 数组需预留固定空间，链表可以动态扩展
5. 数组的空间是从栈中分配，链表在堆中

# 18. tls握手

https://segmentfault.com/a/1190000021559557

# 19. 垃圾回收机制

标记清除：进入环境的变量和被环境中变量引用的变量被标记进入环境，清除掉未被标记的变量

引用计数：循环引用

v8 的垃圾回收机制基于**分代回收机制**，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。

**新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代**。

新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：

（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。

（2）如果对象不存活，则释放对象的空间。

（3）最后将 From 空间和 To 空间角色进行交换。

新生代对象晋升到老生代有两个条件：

（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。

**老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。**

由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。

# 20. 内存泄漏

循环引用，计时器没清楚，全局变量，

# 21.git

git add . 

git commit --m ''

git push建立远程连接  **git remote add origin XXXXX.git**

将远程指定分支 拉取到 本地指定分支上：

git pull origin <远程分支名>:<本地分支名>

回滚：

未进暂存区： git checkout  filename

git checkout .

add 之后： git reset HEAD name

commit之后：git reset --hard ‘commit’

​	git reset -- hard HEAD^ 回到上一个版本
